# 阅读笔记
* webpack构建过程（里面有大致实现webpack的代码）：https://segmentfault.com/a/1190000021494964?utm_source=tag-newest
1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。
2. 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。
3. 确定入口：根据配置中的 entry 找出所有的入口文件。
4. 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
6. 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。
7. 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。
在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。


获取项目的webpack配置文件
开始编译：有一个Compiler类, 把我们的配置项传进去，执行 run 方法开始编译  --- 初始化Compiler类
根据配置的entry找到入口文件，通过babylon转成AST  ---  获取入口文件AST
从入口出发，使用@babel/traverse插件 递归查找所有的依赖模块，主要是把文件路径和文件内容做一个映射，生成依赖关系图
然后需要把AST转换成code  babel-generator
递归解析所有依赖项，生成依赖关系图（使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容）
重写require函数，输出bundle，把文件内容写入到文件系统(node---fs.writeFileSync(filePath, bundle, 'utf-8'))

* webpack热更新原理
- 如果修改了一个或多个文件
- 文件系统接收更改并通知webpack
- webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新
- HMR Server使用webSocket通知HRM runtime需要更新，HMR运行时通过HTTP请求更新jsonp
- HRM运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面更新。

